{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs For full documentation visit mkdocs.org .","title":"Home"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"chapter_1_Overview/how/","text":"Just as we teach babies to speak by encouraging imitation rather than lengthy explanations, learning chip design can follow a similar approach. This book embraces that philosophy: first, we'll show you how things are done, then we'll delve into the 'what' and 'why'. Don't worry about fully grasping every concept immediately. Follow along step-by-step. If you encounter something unclear, don't get bogged down. Keep going, and revisit those tricky spots later. For code you don't understand, AI tools can be invaluable assistants. This \"learn by doing\" approach might seem superficial at first, but it's far more effective than getting lost in the theory and giving up in frustration.","title":"How to read this book?"},{"location":"chapter_1_Overview/what/","text":"","title":"What is this book about?"},{"location":"chapter_x_Module_Verification/review_test_plan/","text":"TODO","title":"Review test plan"},{"location":"chapter_x_Module_Verification/test_plan_template/","text":"[Your Module] Test Plan Version Date Author Changes V0.1 2025-xx-xx [Your Name] Initial draft V0.2 2025-xx-xx [Your Name] Add detailed verification content, strategies, and plans, and document history V1.0 YYYY-MM-DD [Team Member Name] Add timing verification methodology, modify functional coverage goals Prerequisite Understand [Your Project] structure and understand [Your Module] function position in the chip. Need to familiar with SRAM, DRAM memory storage protocol and using scenarios, need to know AES/SM4 ALG/XTS encryption algorithm. Need to know [Relate Knowledge]. Acronyms Short Full CPU Central Process Unit DUT Design Under Test RAM Random Access Memory [FOO] [Full Name] Contents 1.Design Overview 1.1 DUT Structure 1.2 Protocol/Interface 1.3 Configuration/Register 1.4 [Algorithms Introduction] 2.Verification Environment Overview 2.1 Interface 2.2 TB Structure 2.3 Components & Objects 2.4 Check Point 3.Algorithms Implementation 4.Test Requirements 5.Review Meeting Minutes 1.Design Overview 1.1 DUT Structure 1.2 Protocol/Interface 1.3 Configuration/Register 1.4 [Algorithms Introduction] 2.Verification Environment Overview 2.1 Interface 2.2 TB Structure 2.3 Components & Objects 2.4 Check Point 3.Algorithms Implementation 4.Test Requirements We divide [Your Module] into several parts: XXX XXX XXX Item Description Priority & Kind Cover Method Case Name smoke mix all flow/condition High & Random Scoreboard xx_smoke smoke foo bar Medium & Director Function Coverage xx_smoke 5.Review Meeting Minutes +: Add content into document or update content in the document. -: Remove content from document. !: Fix issues or discussion in the document. ?: Open issue from discussion or review. Date Attendee Kind Comments foo bar + foo foo bar ? foo","title":"Test Plan Template"},{"location":"chapter_x_Module_Verification/test_plan_template/#your-module-test-plan","text":"Version Date Author Changes V0.1 2025-xx-xx [Your Name] Initial draft V0.2 2025-xx-xx [Your Name] Add detailed verification content, strategies, and plans, and document history V1.0 YYYY-MM-DD [Team Member Name] Add timing verification methodology, modify functional coverage goals","title":"[Your Module] Test Plan"},{"location":"chapter_x_Module_Verification/test_plan_template/#prerequisite","text":"Understand [Your Project] structure and understand [Your Module] function position in the chip. Need to familiar with SRAM, DRAM memory storage protocol and using scenarios, need to know AES/SM4 ALG/XTS encryption algorithm. Need to know [Relate Knowledge].","title":"Prerequisite"},{"location":"chapter_x_Module_Verification/test_plan_template/#acronyms","text":"Short Full CPU Central Process Unit DUT Design Under Test RAM Random Access Memory [FOO] [Full Name]","title":"Acronyms"},{"location":"chapter_x_Module_Verification/test_plan_template/#contents","text":"1.Design Overview 1.1 DUT Structure 1.2 Protocol/Interface 1.3 Configuration/Register 1.4 [Algorithms Introduction] 2.Verification Environment Overview 2.1 Interface 2.2 TB Structure 2.3 Components & Objects 2.4 Check Point 3.Algorithms Implementation 4.Test Requirements 5.Review Meeting Minutes","title":"Contents"},{"location":"chapter_x_Module_Verification/test_plan_template/#1design-overview","text":"","title":"1.Design Overview"},{"location":"chapter_x_Module_Verification/test_plan_template/#11-dut-structure","text":"","title":"1.1 DUT Structure"},{"location":"chapter_x_Module_Verification/test_plan_template/#12-protocolinterface","text":"","title":"1.2 Protocol/Interface"},{"location":"chapter_x_Module_Verification/test_plan_template/#13-configurationregister","text":"","title":"1.3 Configuration/Register"},{"location":"chapter_x_Module_Verification/test_plan_template/#14-algorithms-introduction","text":"","title":"1.4 [Algorithms Introduction]"},{"location":"chapter_x_Module_Verification/test_plan_template/#2verification-environment-overview","text":"","title":"2.Verification Environment Overview"},{"location":"chapter_x_Module_Verification/test_plan_template/#21-interface","text":"","title":"2.1 Interface"},{"location":"chapter_x_Module_Verification/test_plan_template/#22-tb-structure","text":"","title":"2.2 TB Structure"},{"location":"chapter_x_Module_Verification/test_plan_template/#23-components-objects","text":"","title":"2.3 Components &amp; Objects"},{"location":"chapter_x_Module_Verification/test_plan_template/#24-check-point","text":"","title":"2.4 Check Point"},{"location":"chapter_x_Module_Verification/test_plan_template/#3algorithms-implementation","text":"","title":"3.Algorithms Implementation"},{"location":"chapter_x_Module_Verification/test_plan_template/#4test-requirements","text":"We divide [Your Module] into several parts: XXX XXX XXX Item Description Priority & Kind Cover Method Case Name smoke mix all flow/condition High & Random Scoreboard xx_smoke smoke foo bar Medium & Director Function Coverage xx_smoke","title":"4.Test Requirements"},{"location":"chapter_x_Module_Verification/test_plan_template/#5review-meeting-minutes","text":"+: Add content into document or update content in the document. -: Remove content from document. !: Fix issues or discussion in the document. ?: Open issue from discussion or review. Date Attendee Kind Comments foo bar + foo foo bar ? foo","title":"5.Review Meeting Minutes"},{"location":"chapter_x_Module_Verification/what/","text":"TODO","title":"What work is required for Module Verification?"},{"location":"chapter_x_Module_Verification/write_test_plan/","text":"TODO","title":"Write test plan"},{"location":"chapter_x_Module_Verification/test_bench_template/agent/","text":"xx_agent.sv //============================================================================= // Project : xx // // File Name: xx_agent.sv // // Author : Name : Fengfan Liu // Company: my_company // Year : 10/27/2022 // // Version: 0.1 // //============================================================================= // Description: Agent for xx //============================================================================= `ifndef XX_AGENT_SV `define XX_AGENT_SV class xx_agent extends uvm_agent; `uvm_componet_utils(xx_agent) uvm_analysis_port #(xx_item) analysis_port; xx_config cfg; xx_sequencer sqr; xx_driver drv; xx_monitor mon; local int m_is_active = -1; extern function new(string name, uvm_component parent); extern function void build_phase(uvm_phase phase); extern function void connect_phase(uvm_phase phase); extern task main_phase(uvm_phase phase); extern function uvm_active_passive_enum get_is_active(); endclass: xx_agent function xx_agent::new(string name, uvm_component parent); super.new(name, parent); analysis_port = new(\"\"analysis_port\", this); endfunction: new function void xx_agent::build_phase(uvm_phase phase); if (!uvm_config_db #(xx_config)::get(this, \"\", \"config\", cfg)) begin `uvm_fatal(get_type_name(), $psprintf(\"xx config not found\")); end mon = xx_monitor::type_id::create(\"mon\", this); if (get_is_active() == UVM_ACTIVE) begin drv = xx_driver::type_id::create(\"drv\", this); sqr = src_req_sequencer::type_id::create(\"sqr\", this); end endfunction: build_phase function void xx_agent::connect_phase(uvm_phase phase); if (cfg.vif == null) begin `uvm_warning(get_type_name(), \"xx virtual interface is not set\") end mon.vif = cfg.vif; mon.cfg = cfg; mon.analysis_port.connect(analysis_port); if (get_is_active() == UVM_ACTIVE) begin drv.seq_item_port.connect(sqr.seq_item_export); drv.vif = cfg.vif; drv.cfg = cfg; end endfunction: connect_phase task xx_agent::main_phase(uvm_phase phase); string kind = \"HARD\"; forever begin @(negedge cfg.vif.rst_n); mon.handle_reset(kind); if (drv != null) begin drv.handle_reset(kind); end if (sqr != null) begin sqr.handle_reset(phase, kind); end @(posedge cfg.vif.rst_n); end endtask: main_phase function uvm_active_passive_enum xx_agent::get_is_active(); if (m_is_active == -1) begin if (uvm_config_db #(uvm_bitstream_t)::get(this, \"\", \"is_active\", m_is_active)) begin if (m_is_active != cfg.is_active) begin `uvm_fatal(get_type_name(), $psprintf(\"is_active field in config_db conflicts with config object\")); end else begin m_is_active = cfg.is_active; end end end return uvm_active_passive_enum'(m_is_active); endfunction: get_is_active `endif // XX_AGENT_SV xx_config.sv //============================================================================= // Project : xx // // File Name: xx_config.sv // // Author : Name : Fengfan Liu // Company: my_company // Year : 10/27/2022 // // Version: 0.1 // //============================================================================= // Description: Configuration for agent xx //============================================================================= `ifndef XX_CONFIG_SV `define XX_CONFIG_SV class xx_config extends uvm_object; `uvm_object_utils(xx_config) virtual xx_interface vif; uvm_active_passive_enum is_active = UVM_ACTIVE; bit coverage_enable; bit checks_enable; // when enable, constraint all gap == 0 bit performance_check_enable; rand int sub_seq_numbs; rand int sub_seq_times; rand bit is_repeat[100]; rand int xx_gap[100]; rand int xx_vld_high; rand int timeout; extern function new(string name = \"xx_config\"); constraint xx_gap_cons { if (performance_check_enable) { foreach (xx_gap[i]) { xx_gap[i] == 0; } } else { foreach (xx_gap[i]) { xx_gap[i] dist {0:/30, [5:5*2]:/30, [5*2:5*3]:/10, [5*3:5*5]:/10, [5*5:5*10]:/10, [5*10:5*20]:/9, [5*200:5*400]:/1}; } } } constraint xx_vld_high_cons { xx_vld_high == 1; } // all case should run total_req_num = sub_seq_times * sub_seq_numbs constraint req_num_cons { sub_seq_times dist {[100:200]:/20, [200:300]:/50, [300:400]:/30}; sub_seq_numbs == 7; } constraint timeout_cons { timeout == 10000000; } // End of inlined include file endclass : xx_config function xx_config::new(string name = \"xx_config\"); super.new(name); endfunction : new `endif // XX_CONFIG_SV xx_coverage.sv //============================================================================= // Project : xx // // File Name: xx_coverage.sv // // Author : Name : Fengfan Liu // Company: my_company // Year : 10/27/2022 // // Version: 0.1 // //============================================================================= // Description: Coverage for agent xx //============================================================================= `ifndef XX_COVERAGE_SV `define XX_COVERAGE_SV class xx_coverage extends uvm_subscriber #(xx_item); `uvm_component_utils(xx_coverage) xx_config cfg; xx_item item; bit is_covered; covergroup cg_foo; option.per_instance = 1; cp_foo: coverpoint item.foo; cp_bar: coverpoint item.bar; foo: cross cp_foo, cp_bar; endgroup extern function new(string name, uvm_component parent); extern function void write(input xx_item t); extern function void build_phase(uvm_phase phase); extern function void report_phase(uvm_phase phase); endclass : xx_coverage function xx_coverage::new(string name, uvm_component parent); super.new(name, parent); is_covered = 0; cg_foo = new(); endfunction : new function void xx_coverage::write(input xx_item t); if (cfg.coverage_enable) begin item = t; cg_foo.sample(); if (cg_foo.get_inst_coverage() >= 100) begin is_covered = 1; end end endfunction : write function void xx_coverage::build_phase(uvm_phase phase); if (!uvm_config_db #(xx_config)::get(this, \"\", \"config\", cfg)) begin `uvm_error(get_type_name(), \"src_req config not found\") end endfunction : build_phase function void xx_coverage::report_phase(uvm_phase phase); if (cfg.coverage_enable) begin `uvm_info(get_type_name(), $sformatf(\"Coverage score = %3.1f%%\", cg_foo.get_inst_coverage()), UVM_MEDIUM) end else begin `uvm_info(get_type_name(), \"Coverage disabled for this agent\", UVM_MEDIUM) end endfunction : report_phase `endif // XX_COVERAGE_SV xx_driver.sv xx_interface.sv xx_item.sv xx_monitor.sv xx_sequence_library.sv xx_sequencer.sv","title":"Agent"},{"location":"chapter_x_Module_Verification/test_bench_template/env/","text":"","title":"Env"},{"location":"chapter_x_Module_Verification/test_bench_template/test_bench_template/","text":"","title":"Test Plan Template"},{"location":"chapter_x_Top_Verification/what/","text":"TOP Verification Methodology TOP-level (TOP) verification is one of the most integrated and complex components in the entire verification workflow. This document combines methodological principles with key technical knowledge to provide a comprehensive and executable strategy for conducting TOP-level validation efficiently. 1. Core Principles 1.1 Reporting and Execution: Emphasizing Upward and Downward Synchronization Upward Management : Decompose work into modules, define progress milestones, and assign responsible owners. Use a Portal for visibility and expectation alignment with leadership. Ensure reports are concise and highlight conclusions and objectives clearly. Downward Management : Synchronize regularly to avoid unexpected escalations. Require updates every Thursday before end of day with clear deadlines to avoid ambiguity. 1.2 Clear Positioning: Validation Objectives and Role Division Validation Objective : Focus on system-level scenarios that module-level verification cannot cover. Emphasize validating end-to-end flows and subsystem integration, ignoring low-level module internals. Role Division : TOP Leader : Responsible for defining methodology and overall orchestration. Team Members : Execute based on capability. Strategy-making should be limited to a core few; others execute tasks or debug. 1.3 Simplification and Standardization Avoid Inefficiencies : Sudden Ideas : Avoid ad hoc instructions without follow-up. Over-regulation : Avoid making others fill complex templates or strict formats. Frequent Policy Shifts : Prevent inconsistent directions that confuse execution. Reverse Practice (What to Do) : Jira-Centric Flow : Turn all plans into Jira\u2014either Bug or Case tickets. Let Jira reflect reality. Self-Maintained Tools : All forms/portals are maintained by TOP leads; team members only focus on assigned Jira. Steady Process : Stick to a weekly, repeatable flow so even less experienced team members can keep up. 2. Work Phases TOP verification follows a five-phase process that enables structured progress and consistent output. Phase 1: Initial Debugging Start with basic Apollo Cases and verify them to establish a stable starting point. Phase 2: Regression and Error Classification Run regression with remaining cases. Create Bug Jira tickets and classify them using a Portal for clear ownership. Phase 3: Standard Workflow Established Regression \u2192 Assign Bug Jira \u2192 Portal Auto-Update \u2192 Weekly Report Ensure automated updates and clear reporting. Phase 4: Task Decomposition and Function Coverage Introduce a Task Portal for case generation ownership. Owners are responsible for new case creation for their assigned flows/subsystems. Collect function coverage reports to validate completeness. Phase 5: Final Cleanup and Multi-Dimensional Regression Execute different regression suites in parallel. Finalize by closing all Jira and reporting complete validation coverage. 3. Technical Scope of TOP Verification TOP verification also involves deep technical knowledge across multiple system dimensions. 3.1 Testbench (TB) Integration Module Agent Integration : Incorporate all module-level agents into the TOP-level environment. Bus Configurations : - **Active Agents**: PCIe, DDR, Ethernet, Flash, UART, SPI, etc. - **Passive Agents**: AXI, AHB, GMII, internal custom interfaces. 3.2 System Knowledge (for Debugging) Data Flow : Understand TX/RX paths and module data transformations. Registers : - Knowledge of configuration interfaces (PCIe, JTAG, FW, etc.). - Awareness of chip mode settings and boot-time initialization. Interrupts : - Must verify system-wide interrupt responses (e.g., ECC, counter thresholds). Performance : - Validate metrics like bandwidth, latency, cache hit rates. Clock & Reset : - Confirm correct configuration and reset of all clock domains. Power Domains : - Verify independent domain power-up and correct voltage ranges. 3.3 Non-ASIC Specific Tasks FPGA Verification : Build and simulate FPGA images for early validation. Gate-Level Simulation (GLS) : - Pre- and post-layout verification of synthesized netlists. Acceleration/Emulation : - Adjust module use based on maturity. - Use stubs to replace unrelated modules during slow simulations. Automatic Test Equipment (ATE) : - Generate production test patterns, especially for PHYs. 4. Continuous Improvement 4.1 SOP & Signoff Checklist Optimization Collect pain points from each generation and evolve them into SOPs. Update checklists accordingly. Accumulated knowledge improves both verification quality and organizational maturity. 5. Conclusion The essence of successful TOP verification lies in: \u2705 Goal-Oriented Execution \u2705 Process Clarity and Simplification \u2705 Technical Breadth and Team Collaboration By combining sound methodology with a detailed understanding of SoC-level complexity, TOP verification can become a scalable, repeatable, and highly reliable part of your product development lifecycle.","title":"What work is required for TOP Verification?"},{"location":"chapter_x_Top_Verification/what/#top-verification-methodology","text":"TOP-level (TOP) verification is one of the most integrated and complex components in the entire verification workflow. This document combines methodological principles with key technical knowledge to provide a comprehensive and executable strategy for conducting TOP-level validation efficiently.","title":"TOP Verification Methodology"},{"location":"chapter_x_Top_Verification/what/#1-core-principles","text":"","title":"1. Core Principles"},{"location":"chapter_x_Top_Verification/what/#11-reporting-and-execution-emphasizing-upward-and-downward-synchronization","text":"Upward Management : Decompose work into modules, define progress milestones, and assign responsible owners. Use a Portal for visibility and expectation alignment with leadership. Ensure reports are concise and highlight conclusions and objectives clearly. Downward Management : Synchronize regularly to avoid unexpected escalations. Require updates every Thursday before end of day with clear deadlines to avoid ambiguity.","title":"1.1 Reporting and Execution: Emphasizing Upward and Downward Synchronization"},{"location":"chapter_x_Top_Verification/what/#12-clear-positioning-validation-objectives-and-role-division","text":"Validation Objective : Focus on system-level scenarios that module-level verification cannot cover. Emphasize validating end-to-end flows and subsystem integration, ignoring low-level module internals. Role Division : TOP Leader : Responsible for defining methodology and overall orchestration. Team Members : Execute based on capability. Strategy-making should be limited to a core few; others execute tasks or debug.","title":"1.2 Clear Positioning: Validation Objectives and Role Division"},{"location":"chapter_x_Top_Verification/what/#13-simplification-and-standardization","text":"Avoid Inefficiencies : Sudden Ideas : Avoid ad hoc instructions without follow-up. Over-regulation : Avoid making others fill complex templates or strict formats. Frequent Policy Shifts : Prevent inconsistent directions that confuse execution. Reverse Practice (What to Do) : Jira-Centric Flow : Turn all plans into Jira\u2014either Bug or Case tickets. Let Jira reflect reality. Self-Maintained Tools : All forms/portals are maintained by TOP leads; team members only focus on assigned Jira. Steady Process : Stick to a weekly, repeatable flow so even less experienced team members can keep up.","title":"1.3 Simplification and Standardization"},{"location":"chapter_x_Top_Verification/what/#2-work-phases","text":"TOP verification follows a five-phase process that enables structured progress and consistent output.","title":"2. Work Phases"},{"location":"chapter_x_Top_Verification/what/#phase-1-initial-debugging","text":"Start with basic Apollo Cases and verify them to establish a stable starting point.","title":"Phase 1: Initial Debugging"},{"location":"chapter_x_Top_Verification/what/#phase-2-regression-and-error-classification","text":"Run regression with remaining cases. Create Bug Jira tickets and classify them using a Portal for clear ownership.","title":"Phase 2: Regression and Error Classification"},{"location":"chapter_x_Top_Verification/what/#phase-3-standard-workflow-established","text":"Regression \u2192 Assign Bug Jira \u2192 Portal Auto-Update \u2192 Weekly Report Ensure automated updates and clear reporting.","title":"Phase 3: Standard Workflow Established"},{"location":"chapter_x_Top_Verification/what/#phase-4-task-decomposition-and-function-coverage","text":"Introduce a Task Portal for case generation ownership. Owners are responsible for new case creation for their assigned flows/subsystems. Collect function coverage reports to validate completeness.","title":"Phase 4: Task Decomposition and Function Coverage"},{"location":"chapter_x_Top_Verification/what/#phase-5-final-cleanup-and-multi-dimensional-regression","text":"Execute different regression suites in parallel. Finalize by closing all Jira and reporting complete validation coverage.","title":"Phase 5: Final Cleanup and Multi-Dimensional Regression"},{"location":"chapter_x_Top_Verification/what/#3-technical-scope-of-top-verification","text":"TOP verification also involves deep technical knowledge across multiple system dimensions.","title":"3. Technical Scope of TOP Verification"},{"location":"chapter_x_Top_Verification/what/#31-testbench-tb-integration","text":"Module Agent Integration : Incorporate all module-level agents into the TOP-level environment. Bus Configurations : - **Active Agents**: PCIe, DDR, Ethernet, Flash, UART, SPI, etc. - **Passive Agents**: AXI, AHB, GMII, internal custom interfaces.","title":"3.1 Testbench (TB) Integration"},{"location":"chapter_x_Top_Verification/what/#32-system-knowledge-for-debugging","text":"Data Flow : Understand TX/RX paths and module data transformations. Registers : - Knowledge of configuration interfaces (PCIe, JTAG, FW, etc.). - Awareness of chip mode settings and boot-time initialization. Interrupts : - Must verify system-wide interrupt responses (e.g., ECC, counter thresholds). Performance : - Validate metrics like bandwidth, latency, cache hit rates. Clock & Reset : - Confirm correct configuration and reset of all clock domains. Power Domains : - Verify independent domain power-up and correct voltage ranges.","title":"3.2 System Knowledge (for Debugging)"},{"location":"chapter_x_Top_Verification/what/#33-non-asic-specific-tasks","text":"FPGA Verification : Build and simulate FPGA images for early validation. Gate-Level Simulation (GLS) : - Pre- and post-layout verification of synthesized netlists. Acceleration/Emulation : - Adjust module use based on maturity. - Use stubs to replace unrelated modules during slow simulations. Automatic Test Equipment (ATE) : - Generate production test patterns, especially for PHYs.","title":"3.3 Non-ASIC Specific Tasks"},{"location":"chapter_x_Top_Verification/what/#4-continuous-improvement","text":"","title":"4. Continuous Improvement"},{"location":"chapter_x_Top_Verification/what/#41-sop-signoff-checklist-optimization","text":"Collect pain points from each generation and evolve them into SOPs. Update checklists accordingly. Accumulated knowledge improves both verification quality and organizational maturity.","title":"4.1 SOP &amp; Signoff Checklist Optimization"},{"location":"chapter_x_Top_Verification/what/#5-conclusion","text":"The essence of successful TOP verification lies in: \u2705 Goal-Oriented Execution \u2705 Process Clarity and Simplification \u2705 Technical Breadth and Team Collaboration By combining sound methodology with a detailed understanding of SoC-level complexity, TOP verification can become a scalable, repeatable, and highly reliable part of your product development lifecycle.","title":"5. Conclusion"}]}