{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs For full documentation visit mkdocs.org .","title":"Home"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"chapter_1_Overview/how/","text":"Just as we teach babies to speak by encouraging imitation rather than lengthy explanations, learning chip design can follow a similar approach. This book embraces that philosophy: first, we'll show you how things are done, then we'll delve into the 'what' and 'why'. Don't worry about fully grasping every concept immediately. Follow along step-by-step. If you encounter something unclear, don't get bogged down. Keep going, and revisit those tricky spots later. For code you don't understand, AI tools can be invaluable assistants. This \"learn by doing\" approach might seem superficial at first, but it's far more effective than getting lost in the theory and giving up in frustration.","title":"How to read this book?"},{"location":"chapter_1_Overview/what/","text":"","title":"What is this book about?"},{"location":"chapter_x_Module_Verification/review_test_plan/","text":"TODO","title":"Review test plan"},{"location":"chapter_x_Module_Verification/test_plan_template/","text":"[Your Module] Test Plan Version Date Author Changes V0.1 2025-xx-xx [Your Name] Initial draft V0.2 2025-xx-xx [Your Name] Add detailed verification content, strategies, and plans, and document history V1.0 YYYY-MM-DD [Team Member Name] Add timing verification methodology, modify functional coverage goals Prerequisite Understand [Your Project] structure and understand [Your Module] function position in the chip. Need to familiar with SRAM, DRAM memory storage protocol and using scenarios, need to know AES/SM4 ALG/XTS encryption algorithm. Need to know [Relate Knowledge]. Acronyms Short Full CPU Central Process Unit DUT Design Under Test RAM Random Access Memory [FOO] [Full Name] Contents 1.Design Overview 1.1 DUT Structure 1.2 Protocol/Interface 1.3 Configuration/Register 1.4 [Algorithms Introduction] 2.Verification Environment Overview 2.1 Interface 2.2 TB Structure 2.3 Components & Objects 2.4 Check Point 3.Algorithms Implementation 4.Test Requirements 5.Review Meeting Minutes 1.Design Overview 1.1 DUT Structure 1.2 Protocol/Interface 1.3 Configuration/Register 1.4 [Algorithms Introduction] 2.Verification Environment Overview 2.1 Interface 2.2 TB Structure 2.3 Components & Objects 2.4 Check Point 3.Algorithms Implementation 4.Test Requirements We divide [Your Module] into several parts: XXX XXX XXX Item Description Priority & Kind Cover Method Case Name smoke mix all flow/condition High & Random Scoreboard xx_smoke smoke foo bar Medium & Director Function Coverage xx_smoke 5.Review Meeting Minutes +: Add content into document or update content in the document. -: Remove content from document. !: Fix issues or discussion in the document. ?: Open issue from discussion or review. Date Attendee Kind Comments foo bar + foo foo bar ? foo","title":"Test Plan Template"},{"location":"chapter_x_Module_Verification/test_plan_template/#your-module-test-plan","text":"Version Date Author Changes V0.1 2025-xx-xx [Your Name] Initial draft V0.2 2025-xx-xx [Your Name] Add detailed verification content, strategies, and plans, and document history V1.0 YYYY-MM-DD [Team Member Name] Add timing verification methodology, modify functional coverage goals","title":"[Your Module] Test Plan"},{"location":"chapter_x_Module_Verification/test_plan_template/#prerequisite","text":"Understand [Your Project] structure and understand [Your Module] function position in the chip. Need to familiar with SRAM, DRAM memory storage protocol and using scenarios, need to know AES/SM4 ALG/XTS encryption algorithm. Need to know [Relate Knowledge].","title":"Prerequisite"},{"location":"chapter_x_Module_Verification/test_plan_template/#acronyms","text":"Short Full CPU Central Process Unit DUT Design Under Test RAM Random Access Memory [FOO] [Full Name]","title":"Acronyms"},{"location":"chapter_x_Module_Verification/test_plan_template/#contents","text":"1.Design Overview 1.1 DUT Structure 1.2 Protocol/Interface 1.3 Configuration/Register 1.4 [Algorithms Introduction] 2.Verification Environment Overview 2.1 Interface 2.2 TB Structure 2.3 Components & Objects 2.4 Check Point 3.Algorithms Implementation 4.Test Requirements 5.Review Meeting Minutes","title":"Contents"},{"location":"chapter_x_Module_Verification/test_plan_template/#1design-overview","text":"","title":"1.Design Overview"},{"location":"chapter_x_Module_Verification/test_plan_template/#11-dut-structure","text":"","title":"1.1 DUT Structure"},{"location":"chapter_x_Module_Verification/test_plan_template/#12-protocolinterface","text":"","title":"1.2 Protocol/Interface"},{"location":"chapter_x_Module_Verification/test_plan_template/#13-configurationregister","text":"","title":"1.3 Configuration/Register"},{"location":"chapter_x_Module_Verification/test_plan_template/#14-algorithms-introduction","text":"","title":"1.4 [Algorithms Introduction]"},{"location":"chapter_x_Module_Verification/test_plan_template/#2verification-environment-overview","text":"","title":"2.Verification Environment Overview"},{"location":"chapter_x_Module_Verification/test_plan_template/#21-interface","text":"","title":"2.1 Interface"},{"location":"chapter_x_Module_Verification/test_plan_template/#22-tb-structure","text":"","title":"2.2 TB Structure"},{"location":"chapter_x_Module_Verification/test_plan_template/#23-components-objects","text":"","title":"2.3 Components &amp; Objects"},{"location":"chapter_x_Module_Verification/test_plan_template/#24-check-point","text":"","title":"2.4 Check Point"},{"location":"chapter_x_Module_Verification/test_plan_template/#3algorithms-implementation","text":"","title":"3.Algorithms Implementation"},{"location":"chapter_x_Module_Verification/test_plan_template/#4test-requirements","text":"We divide [Your Module] into several parts: XXX XXX XXX Item Description Priority & Kind Cover Method Case Name smoke mix all flow/condition High & Random Scoreboard xx_smoke smoke foo bar Medium & Director Function Coverage xx_smoke","title":"4.Test Requirements"},{"location":"chapter_x_Module_Verification/test_plan_template/#5review-meeting-minutes","text":"+: Add content into document or update content in the document. -: Remove content from document. !: Fix issues or discussion in the document. ?: Open issue from discussion or review. Date Attendee Kind Comments foo bar + foo foo bar ? foo","title":"5.Review Meeting Minutes"},{"location":"chapter_x_Module_Verification/what/","text":"TODO","title":"What work is required for Module Verification?"},{"location":"chapter_x_Module_Verification/write_test_plan/","text":"TODO","title":"Write test plan"},{"location":"chapter_x_Module_Verification/test_bench_template/agent/","text":"xx_agent.sv //============================================================================= // Project : xx // // File Name: xx_agent.sv // // Author : Name : Fengfan Liu // Company: my_company // Year : 10/27/2022 // // Version: 0.1 // //============================================================================= // Description: Agent for xx //============================================================================= `ifndef XX_AGENT_SV `define XX_AGENT_SV class xx_agent extends uvm_agent; `uvm_componet_utils(xx_agent) uvm_analysis_port #(xx_item) analysis_port; xx_config cfg; xx_sequencer sqr; xx_driver drv; xx_monitor mon; local int m_is_active = -1; extern function new(string name, uvm_component parent); extern function void build_phase(uvm_phase phase); extern function void connect_phase(uvm_phase phase); extern task main_phase(uvm_phase phase); extern function uvm_active_passive_enum get_is_active(); endclass: xx_agent function xx_agent::new(string name, uvm_component parent); super.new(name, parent); analysis_port = new(\"\"analysis_port\", this); endfunction: new function void xx_agent::build_phase(uvm_phase phase); if (!uvm_config_db #(xx_config)::get(this, \"\", \"config\", cfg)) begin `uvm_fatal(get_type_name(), $psprintf(\"xx config not found\")); end mon = xx_monitor::type_id::create(\"mon\", this); if (get_is_active() == UVM_ACTIVE) begin drv = xx_driver::type_id::create(\"drv\", this); sqr = src_req_sequencer::type_id::create(\"sqr\", this); end endfunction: build_phase function void xx_agent::connect_phase(uvm_phase phase); if (cfg.vif == null) begin `uvm_warning(get_type_name(), \"xx virtual interface is not set\") end mon.vif = cfg.vif; mon.cfg = cfg; mon.analysis_port.connect(analysis_port); if (get_is_active() == UVM_ACTIVE) begin drv.seq_item_port.connect(sqr.seq_item_export); drv.vif = cfg.vif; drv.cfg = cfg; end endfunction: connect_phase task xx_agent::main_phase(uvm_phase phase); string kind = \"HARD\"; forever begin @(negedge cfg.vif.rst_n); mon.handle_reset(kind); if (drv != null) begin drv.handle_reset(kind); end if (sqr != null) begin sqr.handle_reset(phase, kind); end @(posedge cfg.vif.rst_n); end endtask: main_phase function uvm_active_passive_enum xx_agent::get_is_active(); if (m_is_active == -1) begin if (uvm_config_db #(uvm_bitstream_t)::get(this, \"\", \"is_active\", m_is_active)) begin if (m_is_active != cfg.is_active) begin `uvm_fatal(get_type_name(), $psprintf(\"is_active field in config_db conflicts with config object\")); end else begin m_is_active = cfg.is_active; end end end return uvm_active_passive_enum'(m_is_active); endfunction: get_is_active `endif // XX_AGENT_SV xx_config.sv //============================================================================= // Project : xx // // File Name: xx_config.sv // // Author : Name : Fengfan Liu // Company: my_company // Year : 10/27/2022 // // Version: 0.1 // //============================================================================= // Description: Configuration for agent xx //============================================================================= `ifndef XX_CONFIG_SV `define XX_CONFIG_SV class xx_config extends uvm_object; `uvm_object_utils(xx_config) virtual xx_interface vif; uvm_active_passive_enum is_active = UVM_ACTIVE; bit coverage_enable; bit checks_enable; // when enable, constraint all gap == 0 bit performance_check_enable; rand int sub_seq_numbs; rand int sub_seq_times; rand bit is_repeat[100]; rand int xx_gap[100]; rand int xx_vld_high; rand int timeout; extern function new(string name = \"xx_config\"); constraint xx_gap_cons { if (performance_check_enable) { foreach (xx_gap[i]) { xx_gap[i] == 0; } } else { foreach (xx_gap[i]) { xx_gap[i] dist {0:/30, [5:5*2]:/30, [5*2:5*3]:/10, [5*3:5*5]:/10, [5*5:5*10]:/10, [5*10:5*20]:/9, [5*200:5*400]:/1}; } } } constraint xx_vld_high_cons { xx_vld_high == 1; } // all case should run total_req_num = sub_seq_times * sub_seq_numbs constraint req_num_cons { sub_seq_times dist {[100:200]:/20, [200:300]:/50, [300:400]:/30}; sub_seq_numbs == 7; } constraint timeout_cons { timeout == 10000000; } // End of inlined include file endclass : xx_config function xx_config::new(string name = \"xx_config\"); super.new(name); endfunction : new `endif // XX_CONFIG_SV xx_coverage.sv //============================================================================= // Project : xx // // File Name: xx_coverage.sv // // Author : Name : Fengfan Liu // Company: my_company // Year : 10/27/2022 // // Version: 0.1 // //============================================================================= // Description: Coverage for agent xx //============================================================================= `ifndef XX_COVERAGE_SV `define XX_COVERAGE_SV class xx_coverage extends uvm_subscriber #(xx_item); `uvm_component_utils(xx_coverage) xx_config cfg; xx_item item; bit is_covered; covergroup cg_foo; option.per_instance = 1; cp_foo: coverpoint item.foo; cp_bar: coverpoint item.bar; foo: cross cp_foo, cp_bar; endgroup extern function new(string name, uvm_component parent); extern function void write(input xx_item t); extern function void build_phase(uvm_phase phase); extern function void report_phase(uvm_phase phase); endclass : xx_coverage function xx_coverage::new(string name, uvm_component parent); super.new(name, parent); is_covered = 0; cg_foo = new(); endfunction : new function void xx_coverage::write(input xx_item t); if (cfg.coverage_enable) begin item = t; cg_foo.sample(); if (cg_foo.get_inst_coverage() >= 100) begin is_covered = 1; end end endfunction : write function void xx_coverage::build_phase(uvm_phase phase); if (!uvm_config_db #(xx_config)::get(this, \"\", \"config\", cfg)) begin `uvm_error(get_type_name(), \"src_req config not found\") end endfunction : build_phase function void xx_coverage::report_phase(uvm_phase phase); if (cfg.coverage_enable) begin `uvm_info(get_type_name(), $sformatf(\"Coverage score = %3.1f%%\", cg_foo.get_inst_coverage()), UVM_MEDIUM) end else begin `uvm_info(get_type_name(), \"Coverage disabled for this agent\", UVM_MEDIUM) end endfunction : report_phase `endif // XX_COVERAGE_SV xx_driver.sv xx_interface.sv xx_item.sv xx_monitor.sv xx_sequence_library.sv xx_sequencer.sv","title":"Agent"},{"location":"chapter_x_Module_Verification/test_bench_template/env/","text":"","title":"Env"},{"location":"chapter_x_Module_Verification/test_bench_template/test_bench_template/","text":"","title":"Test Plan Template"},{"location":"chapter_x_Top_Verification/what/","text":"TOP Verification Overview TOP verification is one of the most highly integrated and complex parts of the overall verification process. We can break it down into several dimensions. Here's a general overview of the tasks involved: 1. Testbench (TB) Integration: Integration of Module Agents: Integrate all previously developed module-level TB agents into the TOP-level TB. Bus Configuration: Reconfigure the stimulus for the System-on-Chip (SoC)'s external communication buses. Agents for these buses should be set to \"active\" mode, meaning they include components like sequences and drivers to manage stimulus generation. Active Agent Configuration (Typically): High-speed interfaces: PCIe, DDR, Ethernet, Flash, etc. Serial interfaces: UART, SPI, JTAG, I2C, etc. Passive Agent Configuration (Typically): Internal communication interfaces. Custom-designed interfaces (implementation depends on the architecture). Common internal interfaces: AXI, AHB, GMII, etc. Agents for these are typically set to \"passive\" mode, meaning they only need to monitor signals to ensure protocol compliance. 2. System Knowledge (Debugging): At the TOP level, many system-level aspects become apparent. A basic understanding of these is crucial for quickly identifying issues and assigning them to the appropriate owner. The level of involvement can vary: Strong Individual: A highly capable verification engineer can perform initial debugging, pinpoint the problem to a system or even a specific module, and then hand it off. Strong Team: A strong team might have individuals responsible for specific test cases. The assigned owner handles any issues that arise within that case, regardless of the cause. Regardless, the following fundamental knowledge is necessary: 2.1 Data Flow: Understand the basic data paths. For example, in a network card, understand the flow of data for transmission (TX) and reception (RX), which modules the data passes through, and how each module processes the data. 2.2 Registers: Know the different methods for configuring chip registers (PCIe, firmware, JTAG, etc.). Understand the overall configuration modes of the chip (e.g., setting PCIe Gen1/2/3, setting network card speed to Gigabit/10 Gigabit). Which registers need to be configured? Crucially, understand the necessary register configurations during chip power-up and the boot process. 2.3 Interrupts: Verify the overall chip interrupt system. This includes (but is not limited to): Interrupts triggered by accumulated error counts. Interrupts triggered by uncorrectable ECC errors. 2.4 Performance: Identify all performance metrics (bandwidth, packet throughput, latency, cache hit rate, etc.). Verify that the performance of each data flow meets the specifications. 2.5 Clock & Reset: Verify the correctness of the clock tree and reset tree. Confirm that each clock domain can be correctly configured and reset. Ensure that all clocks are operating within configurable frequency ranges. 2.6 Power: Verify that all voltage domains are configured correctly. Ensure that each domain can be powered up independently. Confirm that each domain operates within the configurable voltage range. 2.7 TODO: Other points to be added. 3. Non-ASIC Related Aspects: 3.1 FPGA Verification: Create an image for loading onto the FPGA. This image also requires preliminary simulation, though not as rigorously as the ASIC. Basic FPGA knowledge is required. 3.2 Gate-Level Simulation (GLS): Verification of the synthesized gate-level netlist (both pre- and post-layout). In larger companies, this might be the responsibility of the backend team, but in smaller companies, it often falls under TOP verification. This is a large topic in itself. 3.3 Acceleration/Emulation: Based on the verification progress, adjust module configurations. For example, focus on in-house designed modules initially, and later integrate PHY IPs and VIPs. For GLS, consider \"stubbing out\" (replacing with dummy modules) modules unrelated to the current test case to speed up simulation. 3.4 Automatic Test Equipment (ATE): Prepare ATE test patterns in advance for mass production quality checks. A key part of ATE is verifying PHY functionality. It's best to prepare these patterns within the license period of the PHY to ensure technical support. In larger companies, this might be handled by a dedicated DFT (Design for Testability) role. In smaller companies, the TOP verification engineer often handles it. 3.5 TODO: Other points to be added. 4. Other Aspects: 4.1 Signoff Checklist/SOP Optimization: Collect and categorize issues encountered during each product generation. This is unavoidable but provides valuable experience for future iterations. Incorporate these issues into the Standard Operating Procedures (SOPs) and sign-off checklists. This continuously improves design and verification quality. This accumulated knowledge is one of the company's most valuable long-term assets. 4.2 TODO: Other points to be added.","title":"What work is required for TOP Verification?"},{"location":"chapter_x_Top_Verification/what/#top-verification-overview","text":"TOP verification is one of the most highly integrated and complex parts of the overall verification process. We can break it down into several dimensions. Here's a general overview of the tasks involved:","title":"TOP Verification Overview"},{"location":"chapter_x_Top_Verification/what/#1-testbench-tb-integration","text":"Integration of Module Agents: Integrate all previously developed module-level TB agents into the TOP-level TB. Bus Configuration: Reconfigure the stimulus for the System-on-Chip (SoC)'s external communication buses. Agents for these buses should be set to \"active\" mode, meaning they include components like sequences and drivers to manage stimulus generation. Active Agent Configuration (Typically): High-speed interfaces: PCIe, DDR, Ethernet, Flash, etc. Serial interfaces: UART, SPI, JTAG, I2C, etc. Passive Agent Configuration (Typically): Internal communication interfaces. Custom-designed interfaces (implementation depends on the architecture). Common internal interfaces: AXI, AHB, GMII, etc. Agents for these are typically set to \"passive\" mode, meaning they only need to monitor signals to ensure protocol compliance.","title":"1. Testbench (TB) Integration:"},{"location":"chapter_x_Top_Verification/what/#2-system-knowledge-debugging","text":"At the TOP level, many system-level aspects become apparent. A basic understanding of these is crucial for quickly identifying issues and assigning them to the appropriate owner. The level of involvement can vary: Strong Individual: A highly capable verification engineer can perform initial debugging, pinpoint the problem to a system or even a specific module, and then hand it off. Strong Team: A strong team might have individuals responsible for specific test cases. The assigned owner handles any issues that arise within that case, regardless of the cause. Regardless, the following fundamental knowledge is necessary: 2.1 Data Flow: Understand the basic data paths. For example, in a network card, understand the flow of data for transmission (TX) and reception (RX), which modules the data passes through, and how each module processes the data. 2.2 Registers: Know the different methods for configuring chip registers (PCIe, firmware, JTAG, etc.). Understand the overall configuration modes of the chip (e.g., setting PCIe Gen1/2/3, setting network card speed to Gigabit/10 Gigabit). Which registers need to be configured? Crucially, understand the necessary register configurations during chip power-up and the boot process. 2.3 Interrupts: Verify the overall chip interrupt system. This includes (but is not limited to): Interrupts triggered by accumulated error counts. Interrupts triggered by uncorrectable ECC errors. 2.4 Performance: Identify all performance metrics (bandwidth, packet throughput, latency, cache hit rate, etc.). Verify that the performance of each data flow meets the specifications. 2.5 Clock & Reset: Verify the correctness of the clock tree and reset tree. Confirm that each clock domain can be correctly configured and reset. Ensure that all clocks are operating within configurable frequency ranges. 2.6 Power: Verify that all voltage domains are configured correctly. Ensure that each domain can be powered up independently. Confirm that each domain operates within the configurable voltage range. 2.7 TODO: Other points to be added.","title":"2. System Knowledge (Debugging):"},{"location":"chapter_x_Top_Verification/what/#3-non-asic-related-aspects","text":"3.1 FPGA Verification: Create an image for loading onto the FPGA. This image also requires preliminary simulation, though not as rigorously as the ASIC. Basic FPGA knowledge is required. 3.2 Gate-Level Simulation (GLS): Verification of the synthesized gate-level netlist (both pre- and post-layout). In larger companies, this might be the responsibility of the backend team, but in smaller companies, it often falls under TOP verification. This is a large topic in itself. 3.3 Acceleration/Emulation: Based on the verification progress, adjust module configurations. For example, focus on in-house designed modules initially, and later integrate PHY IPs and VIPs. For GLS, consider \"stubbing out\" (replacing with dummy modules) modules unrelated to the current test case to speed up simulation. 3.4 Automatic Test Equipment (ATE): Prepare ATE test patterns in advance for mass production quality checks. A key part of ATE is verifying PHY functionality. It's best to prepare these patterns within the license period of the PHY to ensure technical support. In larger companies, this might be handled by a dedicated DFT (Design for Testability) role. In smaller companies, the TOP verification engineer often handles it. 3.5 TODO: Other points to be added.","title":"3. Non-ASIC Related Aspects:"},{"location":"chapter_x_Top_Verification/what/#4-other-aspects","text":"4.1 Signoff Checklist/SOP Optimization: Collect and categorize issues encountered during each product generation. This is unavoidable but provides valuable experience for future iterations. Incorporate these issues into the Standard Operating Procedures (SOPs) and sign-off checklists. This continuously improves design and verification quality. This accumulated knowledge is one of the company's most valuable long-term assets. 4.2 TODO: Other points to be added.","title":"4. Other Aspects:"}]}